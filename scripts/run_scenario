#!/usr/bin/env python3

# Description:
# A simple script to run a wide range of network positioning scenarios,
# it works as follows:
# - Collect simulation parameter from user
# - Create a temporary configuration file for Charlie from parameters
# - Run the simulation for a user defined number of repetitions for each
#   user defined optimization algorithm
#
# Usage:
# > run_scenario <build-folder>

import sys
import os
from os import path
from subprocess import Popen, PIPE
from random import randrange
from datetime import datetime as dt
import importlib

# -- Configuration template for simulation version 4.0.1

config_template = """
FieldHeight = 6
FieldWidth = 9
SensorRange = 12
SensorFOV = 56.3
ObjectSize = 0.1555

NumberOfSensors = <number-of-sensors>
NumberOfObstacles = <number-of-obstacles>

ObstaclePlacementRandomSeed = <obstacle-randome-seed>

OutsideFieldPenaltyFct = 3
CollisionPenaltyFct = 3

<marked-area>

AllowedDistance = <allowed-distance>
AllowedRotation = <allowed-rotation>

Optimizer = <optimization-algorithm>

# -- Rendering configuration
Zoom = 80
<draw-grid>
DrawSensorLines
<draw-start-positions>

# -- Logging configuration
LogChanges
# LogClearText
LogEvaluations
LogRoundedPositions
"""


def input_str(name: str, default_value: str):
    """Gets an string or a default value by the user"""
    return input(name + " (" + str(default_value) + "): ") or default_value


def input_int(name: str, default_value: int):
    """Gets an integer or a default value from the user."""
    return int(input(name + " (" + str(default_value) + "): ") or default_value)


def input_bool(name: str):
    """Gets a boolean value from the user."""
    return input(name + " (y): ") == "y"


def input_polygon(name: str, default_value: str):
    """Gets a list of points e.g [[0, 0], [2.0, 0], [2, 1], [0, 1]], which
    describe a polygon from the user.
    If no input is provided, the default value is used."""
    polygon = input_str(name, str(default_value))

    if polygon == default_value:
        return default_value

    point_list = polygon\
        .replace(' ', '')\
        .replace('],', ';')\
        .replace(']', '').replace('[', '').split(';')

    if len(point_list) < 3:
        return None

    result = []

    for point in point_list:
        point = point.split(',')
        if len(point) != 2:
            return None
        try:
            result.append([float(point[0]), float(point[1])])
        except ValueError:
            return None

    return str(result)


def print_warning(message: str):
    print("\033[93m {}\033[00m" .format(message))


def print_status(message: str):
    print('\r', end="")
    print(message, end="", flush=True)


def print_help():
    print("Usage:\n"
          "> run_scenario <build-dir> <output-dir>\n"
          "> run_scenario <build-dir> <output-dir> <configs-file>\n"
          "Notes:\n"
          "- The configs file should be contained in the same directory or a "
          "  subdirectory of the script\n"
          "- The configs file must be given as relative path")


def remove_file(file):
    if path.exists(file):
        os.remove(file)


def time_to_str(time: int):
    hours, remainder = divmod(time, 3600)
    minutes, seconds = divmod(remainder, 60)
    return '%d:%d:%d' % (hours, minutes, seconds)


def run_simulation(build_dir: str, output_dir: str, config: dict):
    cwd = os.getcwd()
    number_of_sensors = config['ag']
    number_of_obstacles = config['obs']
    allowed_distance = config['dist']
    allowed_rotation = config['rot']
    optimization_alg = config['alg']
    marked_area = config['ma']
    iterations = config['its']
    repetitions = config['reps']
    output_directory = path.join(cwd, output_dir, config['id'])

    config_file = os.path.join(
        cwd, output_dir, config['id'] + "-" + dt.now().isoformat() + ".conf")

    error_log_file = os.path.join(
        cwd, output_dir,
        config['id'] + "-" + dt.now().isoformat() + ".errorlog")

    sim_path = path.join(
        cwd, build_dir,
        "sensor-positioning.dll:SensorPositioning.StaticSpSimulation")

    percent = 0
    total_time = 0

    print_status("  Started")
    for i in range(repetitions):
        random_seed = randrange(1000000000)
        start_time = dt.now()
        config_text = config_template \
            .replace('<number-of-sensors>', str(number_of_sensors)) \
            .replace('<number-of-obstacles>', str(number_of_obstacles)) \
            .replace('<obstacle-randome-seed>', str(random_seed)) \
            .replace('<allowed-distance>', str(allowed_distance)) \
            .replace('<allowed-rotation>', str(allowed_rotation)) \
            .replace('<draw-grid>', "DrawGrid") \
            .replace('<optimization-algorithm>', optimization_alg)

        config_text = config_text.replace(
            '<marked-area>',
            '' if not marked_area or marked_area == "[]"
            else 'MarkedAreas = ' + str(marked_area))

        config_text = config_text.replace(
            '<draw-start-positions>',
            'DrawStartPositions' if 0 < allowed_distance else '')

        config_text = os.linesep.join(
            [s for s in config_text.splitlines() if s])

        config_file_handler = open(config_file, 'w+')
        config_file_handler.write(config_text)
        config_file_handler.close()

        command = [
            # -- Server version
            # "/usr/bin/mono",
            # "/home/pacosy/student01/charlie-v0.2.3/charlie.exe",
            # -- Local version
            "charlie",
            "--run", sim_path, str(iterations), str(1),
            config_file, output_directory]

        process = Popen(command, stdout=PIPE, stderr=PIPE)
        out, err = process.communicate()
        if err:
            file = open(error_log_file, 'a+')
            file.write('ERROR: ' + str(err) + '\n')
            file.close()
            print("Error occured, see log: " + error_log_file)

        percent += 1
        total_time += (dt.now() - start_time).total_seconds()
        average_time = round(total_time / (i + 1), 4)
        remaining_time = (repetitions - percent) * average_time

        print_status(
            "  Done: " + str(percent) + "/" + str(repetitions) +
            ", Average: " + str(average_time) + "s" +
            ", Remaining: " + time_to_str(remaining_time)
        )

    print()


def read_configs_from_user():
    result = []

    try:
        number_of_sensors = input_int("Number of agents", 1)
        number_of_obstacles = input_int("Number of obstacles", 1)
        marked_area = input_polygon("Marked area", "[]")
        if marked_area is None:
            print_warning("Invalid polygon, using no marked area.")
        allowed_distance = input_int("Allowed distance", -1)
        allowed_rotation = input_int("Allowed rotation", -1)
        optimization_alg = input_str(
            "Optimization alg.", "SPSO-2006, JADE").replace(" ", "").split(",")
        repetitions = input_int("Repetitions", 1000)
        iterations = input_int("Iterations", 600)
        id = input_str("Output ID", "Debug")

        for alg in optimization_alg:
            result.append({
                "ag": number_of_sensors,
                "obs": number_of_obstacles,
                "alg": alg,
                "ma": marked_area,
                "dist": allowed_distance,
                "rot": allowed_rotation,
                "reps": repetitions,
                "its": iterations,
                "id": id + "-" + alg
            })
    except KeyboardInterrupt:
        print("\nAbort")
        exit()

    return result


def read_configs_from_file(file: str):
    if not path.isfile(file):
        print_warning("File '" + file + "' does not exist")
        exit()
    filename, file_extension = path.splitext(file)
    module_path = filename.replace("/", ".").replace("\\", ".")
    try:
        module = importlib.import_module(module_path)
        return module.configs
    except ModuleNotFoundError as err:
        print_warning(str(err))
        exit()


if __name__ == "__main__":
    args = sys.argv
    del args[0]
    args_count = len(args)

    if args_count < 2 or args_count > 3:
        print_help()
        exit()

    build_dir = args[0]
    output_dir = args[1]
    configs = []

    # -- Spawn simulations from user input

    if args_count == 2:
        configs = read_configs_from_user()

    # -- Spawn simulations from a configuration file

    if args_count == 3:
        configs = read_configs_from_file(args[2])

    try:
        if not path.exists(output_dir):
            os.mkdir(output_dir)

        config_count = len(configs)
        i = 0
        for config in configs:
            i += 1
            print("Simulation " + str(i) + "/" + str(config_count) 
                  + ": " + config["id"])
            run_simulation(build_dir, output_dir, config)
    except KeyboardInterrupt:
        print_warning(
            "\nSimulation stopped, please remove corrupted files in '" + 
            output_dir + "' with 'cleanup.py'")
        exit()
